<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>LaunchDarkly Toolbar Auth</title>
  </head>
  <body>
    <script>
      (function () {
        const BROADCAST_CHANNEL_NAME = 'launchdarkly-toolbar-auth';
        const originUrl = new URLSearchParams(window.location.search).get('originUrl');

        // Determine context: are we in an iframe or a popup?
        const isIframe = window.parent && window.parent !== window && window.self !== window.top;
        const isPopup = !!originUrl; // originUrl is only passed when opened as popup

        // Mock authentication - always authenticated in test mode
        console.log('[Mock Auth] Context:', isIframe ? 'iframe' : isPopup ? 'popup' : 'unknown');
        console.log('[Mock Auth] Sending authenticated message to:', originUrl || 'parent window');

        const targetOrigin = originUrl || '*';
        const message = {
          type: 'toolbar-authenticated',
          accountId: 'test-account',
          memberId: 'test-member',
          timestamp: Date.now(),
        };

        const apiReadyMessage = {
          type: 'api-ready',
          accountId: 'test-account',
          memberId: 'test-member',
          timestamp: Date.now(),
        };

        /**
         * Send message to opener or via BroadcastChannel fallback (for Chrome incognito)
         * @param {Object} msg - The message to send
         * @param {string} target - The target origin
         */
        function sendToOpener(msg, target) {
          if (window.opener) {
            // Normal path - direct postMessage to opener
            console.log('[Mock Auth] Sending via window.opener');
            window.opener.postMessage(msg, target);
          } else {
            // Incognito fallback - use BroadcastChannel to communicate with iframe
            // which will relay to the parent window
            console.log('[Mock Auth] window.opener is null, using BroadcastChannel fallback');
            try {
              const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
              channel.postMessage({ ...msg, targetOrigin: target });
              channel.close();
              console.log('[Mock Auth] Message sent via BroadcastChannel');
            } catch (error) {
              console.error('[Mock Auth] BroadcastChannel failed:', error);
            }
          }
        }

        /**
         * Send message to parent window (iframe context)
         * @param {Object} msg - The message to send
         * @param {string} target - The target origin
         */
        function sendToParent(msg, target) {
          if (window.parent && window.parent !== window) {
            console.log('[Mock Auth] Sending via window.parent');
            window.parent.postMessage(msg, target);
          }
        }

        // Send authentication messages based on context
        if (isPopup) {
          // Popup context - send to opener (or BroadcastChannel fallback)
          sendToOpener(message, targetOrigin);
          sendToOpener(apiReadyMessage, targetOrigin);
        } else if (isIframe) {
          // Iframe context - send to parent
          sendToParent(message, targetOrigin);
          sendToParent(apiReadyMessage, targetOrigin);
        } else {
          // Unknown context - try both for backwards compatibility
          sendToParent(message, targetOrigin);
          sendToParent(apiReadyMessage, targetOrigin);
        }

        // === BroadcastChannel Relay for Iframe ===
        // When running as an iframe, listen for BroadcastChannel messages from
        // popup windows (Chrome incognito fallback) and relay them to the parent
        if (isIframe || (!isPopup && window.parent && window.parent !== window)) {
          try {
            const relayChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
            relayChannel.onmessage = function (event) {
              console.log('[Mock Auth] Received BroadcastChannel message, relaying to parent:', event.data);
              const { targetOrigin: msgTargetOrigin, ...msgData } = event.data;
              if (window.parent && window.parent !== window) {
                window.parent.postMessage(msgData, msgTargetOrigin || '*');
              }
            };
            console.log('[Mock Auth] BroadcastChannel relay listener active');
          } catch (error) {
            console.error('[Mock Auth] Failed to set up BroadcastChannel relay:', error);
          }
        }

        // Listen for API requests via postMessage
        window.addEventListener('message', function (event) {
          console.log('[Mock Auth] Received message:', event.data);

          const { type, requestId } = event.data;

          if (type === 'logout') {
            // Handle logout request
            console.log('[Mock Auth] Processing logout request');
            event.source.postMessage(
              {
                type: 'logout-response',
                requestId: requestId,
                timestamp: Date.now(),
              },
              event.origin,
            );
          } else if (type === 'get-projects') {
            // Return mock projects
            event.source.postMessage(
              {
                type: 'get-projects-response',
                requestId: requestId,
                data: [
                  { key: 'test-project', name: 'Test Project' },
                  { key: 'demo-project', name: 'Demo Project' },
                ],
              },
              event.origin,
            );
          } else if (type === 'get-flags') {
            // Return mock flags for a project with pagination
            const { projectKey, limit = 20, offset = 0 } = event.data;

            // Generate a larger set of mock flags for pagination testing
            const totalFlags = 50;
            const allFlags = [];

            for (let i = 1; i <= totalFlags; i++) {
              allFlags.push({
                key: `flag-${i}`,
                name: `Flag ${i}`,
                kind: i % 3 === 0 ? 'boolean' : i % 3 === 1 ? 'multivariate' : 'string',
                description: `Mock flag ${i}`,
                archived: false,
                clientSideAvailability: {
                  usingEnvironmentId: false,
                  usingMobileKey: false,
                },
                customProperties: {},
                variations: [],
                environments: {
                  production: {
                    on: true,
                    fallthrough: { variation: 0 },
                  },
                },
              });
            }

            // Paginate the flags
            const paginatedFlags = allFlags.slice(offset, offset + limit);
            const hasMore = offset + limit < totalFlags;

            event.source.postMessage(
              {
                type: 'get-flags-response',
                requestId: requestId,
                data: {
                  items: paginatedFlags,
                  _links: {
                    self: { href: `/api/v2/flags/${projectKey}?limit=${limit}&offset=${offset}` },
                    ...(hasMore && {
                      next: { href: `/api/v2/flags/${projectKey}?limit=${limit}&offset=${offset + limit}` },
                    }),
                    ...(offset > 0 && {
                      first: { href: `/api/v2/flags/${projectKey}?limit=${limit}&offset=0` },
                    }),
                  },
                  totalCount: totalFlags,
                },
              },
              event.origin,
            );
          } else if (type === 'get-flag') {
            // Return detailed mock flag info
            const { flagKey } = event.data;
            event.source.postMessage(
              {
                type: 'get-flag-response',
                requestId: requestId,
                data: {
                  key: flagKey,
                  name: flagKey
                    .split('-')
                    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
                    .join(' '),
                  kind: flagKey.includes('boolean') ? 'boolean' : 'multivariate',
                  description: `Mock flag: ${flagKey}`,
                  variations: [
                    { _id: 'var-1', value: true },
                    { _id: 'var-2', value: false },
                  ],
                  environments: {
                    production: {
                      on: true,
                      fallthrough: { variation: 0 },
                      rules: [],
                    },
                  },
                },
              },
              event.origin,
            );
          }
        });
      })();
    </script>
  </body>
</html>
