---
description: Testing patterns and standards for Vitest unit tests and Playwright e2e tests
globs: ['**/*.test.tsx', '**/*.test.ts', '**/e2e/**', '**/tests/**', '**/*.spec.ts']
alwaysApply: false
---

---

description:
globs: _.test.tsx,_.test.ts
alwaysApply: false

---

# Testing Patterns for LaunchDarkly Toolbar

## Unit Testing with Vitest

### Test Structure

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { Component } from './Component';

describe('Component', () => {
  it('should render correctly', () => {
    render(<Component />);
    expect(screen.getByRole('button')).toBeInTheDocument();
  });
});
```

### Testing Animated Components

- Mock Framer Motion for unit tests
- Focus on state changes, not animation implementation
- Test component behavior at different animation states

### Context Testing

- Wrap components with required providers (`SearchProvider`, `LaunchDarklyToolbarProvider`)
- Test context interactions and state changes
- Mock context values when needed

```typescript
// Example context wrapping
const AllProviders = ({ children }: { children: React.ReactNode }) => (
  <SearchProvider>
    <LaunchDarklyToolbarProvider config={{ projectKey: 'test' }}>
      {children}
    </LaunchDarklyToolbarProvider>
  </SearchProvider>
);

render(<Component />, { wrapper: AllProviders });
```

### Service Mocking

Mock external services for consistent testing:

```typescript
// Mock DevServerClient
vi.mock('../services/DevServerClient', () => ({
  DevServerClient: vi.fn().mockImplementation(() => ({
    getAvailableProjects: vi.fn().mockResolvedValue(['test-project']),
    setProjectKey: vi.fn(),
    getProjectData: vi.fn().mockResolvedValue({
      sourceEnvironmentKey: 'test-environment',
      flagsState: {},
      overrides: {},
      availableVariations: {},
      _lastSyncedFromSource: Date.now(),
    }),
    setOverride: vi.fn(),
    clearOverride: vi.fn(),
    healthCheck: vi.fn().mockResolvedValue(true),
  })),
}));

// Mock FlagStateManager
vi.mock('../services/FlagStateManager', () => ({
  FlagStateManager: vi.fn().mockImplementation(() => ({
    getEnhancedFlags: vi.fn().mockResolvedValue({}),
    setOverride: vi.fn(),
    clearOverride: vi.fn(),
    subscribe: vi.fn().mockReturnValue(() => {}),
  })),
}));
```

### Event Testing

- Use `fireEvent` for user interactions
- Test keyboard navigation and accessibility
- Verify proper event handlers are called

## E2E Testing with Playwright

### Test Organization

- Place e2e tests in `e2e/tests/`
- Use descriptive test names that explain user scenarios
- Group related tests in the same file

### Page Object Pattern

```typescript
class ToolbarPage {
  constructor(private page: Page) {}

  async expandToolbar() {
    await this.page.click('[data-testid="toolbar-logo"]');
  }

  async selectTab(tabName: string) {
    await this.page.click(`[data-testid="tab-${tabName}"]`);
  }
}
```

### Animation Testing

- Wait for animations to complete before assertions
- Use `waitFor` utilities for dynamic content
- Test both expanded and collapsed states

### Accessibility Testing

- Include keyboard navigation tests
- Verify ARIA labels and roles
- Test screen reader compatibility

## Test Data Organization

### Centralized Mock Data

- Store mock data in `src/tests/mocks/`
- Use typed exports for consistency
- Keep mock data realistic but simple

```typescript
// src/tests/mocks/flags.ts
import { FeatureFlag } from '../../ui/Toolbar/types';

export const mockFeatureFlags: FeatureFlag[] = [
  {
    id: 'edge-caching',
    name: 'Edge caching rules v2',
    custom: false,
    enabled: true,
    description: 'Improved caching rules for edge servers',
    lastModified: new Date('2024-01-15'),
    environment: 'production',
  },
  // ... more flags
];
```

### Mock Data Usage

Import and use centralized mock data:

```typescript
import { mockFeatureFlags } from '../../../tests/mocks/flags';

// Use in tests
expect(component).toRenderFlags(mockFeatureFlags);
```

### Mock Data Best Practices

- Use realistic data that mirrors production
- Include edge cases (long names, special characters)
- Keep data sets small but comprehensive
- Update mock data when real data structures change

## Component-Specific Testing

### Tab Content Testing

Test tab content components with proper context:

```typescript
describe('FlagDevServerTabContent', () => {
  it('filters flags based on search term', () => {
    render(
      <SearchProvider>
        <LaunchDarklyToolbarProvider config={{ projectKey: 'test' }}>
          <FlagDevServerTabContent />
        </LaunchDarklyToolbarProvider>
      </SearchProvider>
    );

    // Test search functionality
  });
});
```

### Error State Testing

Test error handling components:

```typescript
describe('ErrorMessage', () => {
  it('displays error message correctly', () => {
    render(<ErrorMessage error="Test error message" />);
    expect(screen.getByText('Test error message')).toBeInTheDocument();
  });
});

describe('GenericHelpText', () => {
  it('displays title and subtitle', () => {
    render(<GenericHelpText title="No results" subtitle="Try adjusting search" />);
    expect(screen.getByText('No results')).toBeInTheDocument();
    expect(screen.getByText('Try adjusting search')).toBeInTheDocument();
  });
});
```

### Search Functionality Testing

Test search context integration:

```typescript
describe('Search functionality', () => {
  it('filters content based on search term', () => {
    const TestComponent = () => {
      const { searchTerm, setSearchTerm } = useSearchContext();
      return (
        <div>
          <input
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
          <div>{searchTerm}</div>
        </div>
      );
    };

    render(
      <SearchProvider>
        <TestComponent />
      </SearchProvider>
    );

    fireEvent.change(screen.getByRole('textbox'), { target: { value: 'test' } });
    expect(screen.getByText('test')).toBeInTheDocument();
  });
});
```

## Best Practices

### Test Organization

- Group related tests in describe blocks
- Use descriptive test names that explain behavior
- Test behavior, not implementation details
- Use data-testid attributes for reliable element selection

### Mock Management

- Keep mocks focused and minimal
- Reset mocks between tests when needed
- Mock at the right level (services vs components)
- Avoid external dependencies in tests

### Performance Testing

- Test virtualized components with large datasets
- Verify animation performance doesn't block UI
- Test search performance with large flag sets

### Integration Testing

- Test component interactions across contexts
- Verify data flow between providers and consumers
- Test error boundaries and fallback states
